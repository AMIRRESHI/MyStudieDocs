router-outlet directive availble from router package & where to display view

router package directives: 1. routerLink:'/link'  specifies the path
						   2. routerLinkActive: ""
							
@angular/router
setup route array: -> requrest path	-> check in that array & router has states means which state you are in						
<a [routerLink]="['/animals'], animal.name">

component on intialised once when the first route is navigated to , any child routes navigated to after that wont be called on with ngonint
Rotuer is singleton
-> prarmetrised routes
-> wild card , query params , child routes, modules with specific routes, lazy loading, route guard, 

RouterModule.forRoot() - > forroot make it available for the entire application

activatedRoute to get route params

Redirect Routes -> path when empty then pathmatch should be full


ProvideIn: at component level (makes tree shaking active) root
For singleton use injectable root approach.
DI token created, Goes to DI container, check for how to inject class create/use existing. 
CourserService injected by angular. How angular is creating this couses service ?
NullInjector DI of angular doesnot know how to create its dependency. DI has to create an object of it somehow & which is being done by provider. provider will give DI a function know as factory function, generates the dependncy when it sees that its needed & passes it to the part of application.. provider provides dependency
We need to give our DI a unique name called token & instantiate that injectionToken
provide: 'its the unique token mentioned here meaning we have uniquely identified the dependency we are configuring', now provide the provider function  useFactory: courserService, deps: 'it requires other dependencies e.g httpclient'. 
Angular support className as injection tokens, becoz className exists at runtime under the form of a constructor function. Interface doesnot exist at runtime as it being compile time instruct only. Using useClass angular knows that it need to call new constructor on this class & it needs to provide the needed dependencies. Manual injection token are not are not required anymore, becoz anngualr is internally using classname as uniqueidentifire. To tell angular injector about our employee service we need to register the service with angular injector. If a service is not injected in the bundle they are not included in the bundle

Inject decorator is usefull when we cant use class as DI token
Resolution modifiers :
	optional:			
	self:
	skipSelf:
	host:

class Providers:
	useClass				provider & useClass -> from where to create an object
	useExisting				use an existing object 
	useFactory				to make providers your providers more flexible
	useValue				used as injection token

provider: [useClass, useExisting, how to & not to make a dependencyInjection tree shakable by mentioning provideIn: 'root' or 'any'
		useValue: to pass any value from module/feature module & then we can use Inject property inside the constructor to load different key depending upon different modules, useFactory: means to load different object based on the business logic  ]
		
Angular 3 skipped because core version was ahead of all
March/Oct releases
Anguar 5 http depcreated & httpclient was introduced
In Angular 7 virtual scrolling was introduced
Angular 8 has differential loading of browsers, with this you can deploy your application
Angular 9 (major release)
Ivy compliler

Ivy: smaller(tree shakable: dead code elimination), faster comilation(check for those what only changed), better debugging(can do template debuggin), improved type safety, faster testing, improved build error, improved internationalization
	improved css class & style binding, easier to ship, angular material will ship fully comiled code
	its kind of excucutable representation how to create/update template
	If Di is not used ivy will removve it

earlier build: dev/AOT
AOT: if there is any error fix that time only, if not fixed application will not compile e.g garbage collection
before version there were view engines
compiler: to transform written in angular directive syntax into js instructions enriched with changes detection 
runtime: executable code prduced by angular
parsing & executing
angular material then angular & now material comes with precompiled
previously since we are in shipping AOT compiled code every project code would have to recompile every component library its using but now we are able to ship actual aot compiled code as part of npm when you do ng build its just build your app
locality principle: single file compilation 
ng-if doest need to know its dependiencies nothing else is requried to recompile it
AOT: Rendering faster precompiled & loads executable code
	inlines all the html & css by not making the ajax call for those
	Reduction in injection better security
jit vs aot jit compiles app at tuntime, it has to donwload compiler jit
	jit bundle code larger as its having compiler code also

***********

Dynamic component:
	directive -> *ngComponentOutlet=dummyComponnet
EntryComponent spicifies list of components that should be compiled when the module is defined which will store component factory resolver 	
EntryComponent not required in Anguar9 because of IvyRender


Angular bootprocess: on ng-serve angular code compilation happens converting ts code into js. The module is bootstraped meaning, dynamically selector code is attached to index.html . first cmponent, the module should load
package json -> calls build config in angular.json

Dependencies -> all required to run in prod
devDep -> must to develop app
major, minor, minor-patches
ng-test -> test & run all our unit test
ng-build -> build your app & make it ready for production deploymernt
@Decorator -> definition what it has

component is also directive

Directive -> to extentd, change, modify html giving new syntax
1. component : default app comp
2. Structural: updates structure of view, ngFor, ngIf, ngSwitch: ngswitchCase-ngSwitchDefault, shape/reshape dom, recognize it with * sign
	[ngSwitch]=""
3. Attribute: ngStyle, ngClass(build InDirectives)
4. customDirective: 


Data Binding - interaction of all files in component
1. One-way: 
	conponent to view:
		Interpolation 
		property binding: we write it in square brackets, we can bind any/mulitple properties to dom e.g [innerHtml], [title], [src] [alt], [placeholder], 		[style.color], [ngClass]="expresssion"
		Style binding
		Attribute binding: [arrt.<name>]="experession" e.g colspan example
	view to component:
		Event binding: (click)="method()"
2. two-way: -> <- kind of combination of property+event binding ng-model(its a built in directive)
3. pipes -> used to transform data
	Built In pipes:
		Lowercase, Uppercase, Currency, Date, Percent, JSON
	paratemertised
		currency: which country {{ currencyValue | currency: 'usd' }}
	chaining
		{{ dob | date | upperCase }}
	custom pipes
	
Forms:
		2 way data binding 
		change traking
		Validations
		Error handling
		Unit testing
	Form types
		Static /Template driven
		Dynamic/Reactive form

pure pipe : dont use function calls in teamplate instead pure pipe benefit is it triggers datatransformation or calculation only incase input has been changed when function will be excuted everytime changedetection runs

lazy loaded modules creates its own injector which are children for our root injector
child model injector ? lazy loading		
		
Change Detection: track updated changes in app state & render it.. 		
ExpressionChangedAfterItHasBeenCheckedError comes in development mode only
Zones just tell angular when do run changedetection. it has all asyn api in browser & when the code interacts with one of those api it causes change detection to accur

Angular creates instance of components it has to create dom nodes for these html elements.. place for angular to put this reference because component is destroyed remove these dom nodes.. As comiler goes through the template it checks for bindings.. Internally it checks for views.. Dirty checking prev vs current

CheckAndUpdateVeiw()

Angular Ivy: ivy compiler & runtime by default
view engine takes templ & translates in js/html

Css:
_ngContent-c1 attribute get added in dom for styling & styling has that attribute (chosen by angular team) 
added as an attribute in @component decorator :host-context binding
:host is a special selector provided for angular components -> 1 level up
encapsulation: emulated (its the default 1- scoped styles)
Native: uses native behaviour of browsers.. might change in furture not to be used now
ShadowDom: external/internal styles dont share
showdomDom: new dom feature to creatre cusotom componnents(by default its off.. turn it on in setting e.g video player buttons)

ngAfterContentInit(): called after a directive content has been fully initialised, invoked after anuglar performs any content projection,
					 - Once. After the external content is injected by the parent through ngContent @contentChild available.
					 - your projected content gets initialised before the view that is why content child is not accesible inside the component, @contentChild will not work in component-> it given undefined because  your content hasn't been intialised..
ngAferViewChecked(): update property of parent component after angular checked the parent component // gives error & works in ngOninit..
					- Once. After the component & child views are initialised. @ViewChild is available
both ***Checked are related functions are related to Change Detection

@HostListner: can listen to events on dom host e.g by using moveover click events
@Hostbinding: can listen to events & change properties of the element e.g add border on hover 

************************************************************************************************
RXJS:
Observabe: tracking state with observables, mechanism to track changes on
Promise: single value, Not lazy,cant be cancelled, 2 paramerters callback func: o & rejected
Subscribe: Emits Xultiple values, lazy, can be cancelled, 3 parameters next, error, complete
			after error it doesnt got to complete
Observalue can be sync/asyc but promise are always async
			
async await: better way of handling promises	
javascript promises came in ES6
async await just uses promise behind the scenes new feature with ES8, looks like sync code

steam of values e.g click on browser page
setInterval()
setTimeout() ->  emits only 1 value, no way it could emit an error
in observable subscribe main funda is that, "do not nest subscribe calls"
shareReplay(), tap(), map(), map(),
concat() -> sequentialy completes if a, b, c. if one fails it stops there
fromObservable() it takes a promise & converts it into the observable
concatMap() e.g form save on changes should triggers server call sequentialy to save the data. If the order of the observable is important use it
merge() to execute the things in parallel
mergeMap() If the order of the observable is not important, in parallel use it
exaustMap() ignoring extra values while current observable is still ongoing e.g mulitple save clik some save clicks will be ignored
switchMap() e.g searchType ahead cancel ongoing request & then switch to the new http request
debounceTime()
distinctUntillChanged()
catchError()
finalize() to release resources on error
retryWhen() on fail retry after few seconds
delayWhen()
startWith() start with may be some inital value e.g "" empty string
throttle() limit the output by limiting the number values that can be emitted in a certain interval
throttleTime() better than throttle
forkJoin() launch several tasks in parallel. paralley call 2 http wait till both execute & then join both together
behaviourSubject() always provide something to subscribers even if the subscription happen late we still want to get the latest values emitted by the observable befor the subscription & also pass the inital value
withLatestFrom() allows to combine mulitple observables together long ruiing or not by taking the latest value emitted from each observable & providing that to the next observable in th

To read: 

forkjoin vs combine latest
sentry: performance tuning
hot & cold observable
box sizing

************************************************************************************************
javascript:
JS objects are muttable: it can be chaged/updated
`
for...of skips protoype added, You can stop or break a for...of loop at anytime
for...in iterate protoype
for/in and forEach() skip empty elements, also known as "holes", in the array
forEach() does not support break.
The for–in loop is for looping over object properties.
The for–of loop is for looping over data—like the values in an array.

 
Arrow functions are lexically bound to this keyword, unlike the normal functions which are dynamically bound.
Arrow functions cannot be used as a method and constructors

1.) Arrow Functions do not have a binding with this, i.e. arrow functions do not have their own this.
arrow functions dont rebind this 
if we refactore settimeout callback fucntion to arrow function.. in other words with arrow syntax this in not reset instead it inherits this in the context in which this code is defined


**************
click event bubbles up to the component hierarchy however custom event doesnot

conditional styles [ngClass]= string array configObject => state classes
[ngStyle] same as above
[ngSwitch]="course.category"

pipe to trasform data & display in another form to the user
http header identifying the user 

Content projection: to create configurable component
partial content proj: using select 

host element is on which the directive is applied

first constructor gets called then inputs are calculated
ngDoCheck customChangeDetection
it called before ngOninit() & subsequently when any of the input proper change. ngOnchanges will only get triggered if the input object itself changes not if its one of the property changes
Unidirectional data flow in angular application

afterViewChecked setting the focus after getting the new data or scrolling to some place after getting the data


Jasmine spy
jasmine.createSpyObject

jasmine behaviour driven
test are know as testsuit
karma used internally by angular cli
expect(result) to be4
expect(result) to be4 tohavebeencalledtimes
mock all dependencies
ecpect(coursees)tobetruthy
fit to focus our furntion execution
exppectone('api/courses')
zonejs to implement change detection
tick utility controls the evoution of time inside a fake async zone

all js objects by default are mutable meaning we can change any property without replacing the object
angular is trying to diplay  data from mutable objects on the screen if anything happens at the browser e.g a native dom click event, timeout etc that asyc event will modify the data
onPush : important to avoid to mutate data directly at the level of the view

attibute directive (one time binding): type="beginner" instead of [type]="'beginner'"
changeDetectorRef to implement custom change detection in ngDoCheck event. each component has changeDetectorRef

event
1. dom eventor custom event
2. input data has changed
3. observable with async has changed any data

viewChild quering we can get reference to dom element/component (ngAfterVViewInit)

contentChild to see through the projected content elements. The scope of the contentChild query is what is there inside ng content.
restrickted to the content part of the componnet. contentChild query cant see anything in the parent template. if we require programatic reference to projected content then use contentChild

ng:deep to bypass angular style encapsulation whatever css comes after ngDeep dont make that component specific
ngAfterContentChecked: called after the projected content part is checked for changes
both lifecycle hook are called with every change detection execution 

